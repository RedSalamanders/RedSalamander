name: Release

"on":
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Tag to release (e.g., v7.0.0). Leave blank to skip release creation."
        required: false
        type: string
      build_msix:
        description: "Also build MSIX (off by default)."
        required: false
        type: boolean
        default: false
      sign_msix:
        description: "Sign MSIX if certificate secrets are configured (only if build_msix=true)."
        required: false
        type: boolean
        default: true

permissions:
  contents: write

jobs:
  build:
    runs-on: windows-latest
    env:
      CONFIGURATION: Release
      PLATFORM: x64
      VCPKG_ROOT: ${{ github.workspace }}\vcpkg
      VCPKG_INSTALLED_DIR: ${{ github.workspace }}\.build\vcpkg_installed
      VCPKG_DEFAULT_TRIPLET: x64-windows
      BUILD_MSIX: ${{ github.event_name == 'workflow_dispatch' && inputs.build_msix }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Visual Studio 2026 Build Tools (v145)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          # Visual Studio 2026 build tools aren't available on the hosted runner by default.
          # Use Chocolatey to install the official VS installer payload reliably.
          choco install visualstudio2026buildtools -y --no-progress
          $exitCode = $LASTEXITCODE
          if ($exitCode -eq 3010) {
            Write-Host "VS Build Tools installed successfully (reboot recommended but not required for CI)"
            exit 0
          }
          if ($exitCode -ne 0) {
            throw "visualstudio2026buildtools install failed with exit code $exitCode"
          }

      - name: Install Visual C++ build tools workload (v145)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          choco install visualstudio2026-workload-vctools -y --no-progress
          $exitCode = $LASTEXITCODE
          if ($exitCode -eq 3010) {
            Write-Host "VC tools workload installed successfully (reboot recommended but not required for CI)"
            exit 0
          }
          if ($exitCode -ne 0) {
            throw "visualstudio2026-workload-vctools install failed with exit code $exitCode"
          }

      - name: Install UWP build tools workload (MSIX)
        if: ${{ env.BUILD_MSIX == 'true' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          choco install visualstudio2026-workload-universalbuildtools -y --no-progress
          $exitCode = $LASTEXITCODE
          if ($exitCode -eq 3010) {
            Write-Host "UWP build tools workload installed successfully (reboot recommended but not required for CI)"
            exit 0
          }
          if ($exitCode -ne 0) {
            throw "visualstudio2026-workload-universalbuildtools install failed with exit code $exitCode"
          }

      - name: Select MSBuild (VS 2026)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (-not (Test-Path $vswhere)) {
            throw "vswhere.exe not found: $vswhere"
          }

          $msbuild =
            (& $vswhere -latest -products * -prerelease -version '[18.0,19.0)' -find 'MSBuild\Current\Bin\MSBuild.exe' 2>$null) |
            Select-Object -First 1

          if (-not $msbuild) {
            $msbuild =
              (& $vswhere -latest -products * -prerelease -version '[18.0,19.0)' -find 'MSBuild\Current\Bin\amd64\MSBuild.exe' 2>$null) |
              Select-Object -First 1
          }

          if (-not $msbuild -or -not (Test-Path $msbuild)) {
            Write-Host "Installed Visual Studio instances:" -ForegroundColor Yellow
            & $vswhere -all -prerelease -products *
            throw "MSBuild for Visual Studio 2026 (18.x) not found after installation."
          }

          $msbuildDir = Split-Path -Parent $msbuild
          $msbuildDir | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          "MSBUILD_EXE_PATH=$msbuild" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          & $msbuild -version

      - name: Cache vcpkg
        uses: actions/cache@v4
        with:
          path: |
            .build/vcpkg_installed
            vcpkg\downloads
          key: ${{ runner.os }}-vcpkg-${{ hashFiles('vcpkg.json', 'vcpkg-configuration.json') }}

      - name: Bootstrap vcpkg
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $manifestPath = Join-Path $env:GITHUB_WORKSPACE "vcpkg.json"
          if (-not (Test-Path $manifestPath)) {
            throw "vcpkg.json not found at: $manifestPath"
          }

          $baseline = (Get-Content -Path $manifestPath -Raw | ConvertFrom-Json)."builtin-baseline"
          if ([string]::IsNullOrWhiteSpace($baseline)) {
            throw "vcpkg.json builtin-baseline is missing/empty. Set builtin-baseline to a valid vcpkg commit."
          }

          $baseline = $baseline.Trim()
          if ($baseline -notmatch '^[0-9a-fA-F]{40}$') {
            throw "vcpkg.json builtin-baseline is not a 40-character commit SHA: '$baseline'"
          }

          $baseline = $baseline.ToLowerInvariant()
          Write-Host "vcpkg builtin-baseline: $baseline"

          # Cache may restore vcpkg\downloads without the vcpkg repo itself.
          $bootstrap = Join-Path $env:GITHUB_WORKSPACE "vcpkg\\bootstrap-vcpkg.bat"
          $gitDir = Join-Path $env:GITHUB_WORKSPACE "vcpkg\\.git"
          if (-not (Test-Path $bootstrap) -or -not (Test-Path $gitDir)) {
            $downloads = Join-Path $env:GITHUB_WORKSPACE "vcpkg\\downloads"
            $downloadsStash = $null

            if (Test-Path $downloads) {
              $downloadsStash = Join-Path $env:RUNNER_TEMP "vcpkg-downloads"
              if (Test-Path $downloadsStash) { Remove-Item $downloadsStash -Recurse -Force }
              Move-Item -Path $downloads -Destination $downloadsStash
            }

            if (Test-Path .\\vcpkg) { Remove-Item .\\vcpkg -Recurse -Force }
            git clone https://github.com/microsoft/vcpkg .\\vcpkg
            if ($LASTEXITCODE -ne 0) { throw "git clone vcpkg failed with exit code $LASTEXITCODE" }

            if ($downloadsStash) {
              if (Test-Path $downloads) { Remove-Item $downloads -Recurse -Force }
              Move-Item -Path $downloadsStash -Destination $downloads
            }
          }

          Push-Location .\\vcpkg

          # vcpkg port versioning needs git objects that are typically missing in shallow clones.
          # Unshallow to avoid "failed to unpack tree object" during `vcpkg install`.
          $isShallow = (git rev-parse --is-shallow-repository).Trim()
          if ($isShallow -eq "true") {
            Write-Host "vcpkg repo is shallow; fetching full history..."
            git fetch --prune --unshallow origin
            if ($LASTEXITCODE -ne 0) {
              throw "git fetch --unshallow failed (exit code $LASTEXITCODE)."
            }
          }

          # Ensure the pinned baseline commit exists locally; shallow clones won't include it.
          git cat-file -e "$baseline^{commit}" 2>$null
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Fetching vcpkg baseline commit..."

            git fetch --depth 1 origin $baseline
            if ($LASTEXITCODE -ne 0) {
              $isShallow = (git rev-parse --is-shallow-repository).Trim()
              if ($isShallow -eq "true") {
                git fetch --prune --unshallow origin
              } else {
                git fetch --prune origin
              }

              if ($LASTEXITCODE -ne 0) {
                throw "git fetch failed while trying to obtain vcpkg baseline commit '$baseline' (exit code $LASTEXITCODE)."
              }
            }

            git cat-file -e "$baseline^{commit}" 2>$null
            if ($LASTEXITCODE -ne 0) {
              throw "vcpkg baseline commit not found after fetch: $baseline"
            }
          }

          # Fail fast with a clear message if the manifest pins an unsupported baseline commit.
          git show "${baseline}:versions/baseline.json" 1>$null 2>$null
          if ($LASTEXITCODE -ne 0) {
            throw "vcpkg.json builtin-baseline '$baseline' is invalid: versions/baseline.json missing at that commit. Update vcpkg.json builtin-baseline."
          }

          Pop-Location

          & $bootstrap
          if ($LASTEXITCODE -ne 0) { throw "bootstrap-vcpkg.bat failed with exit code $LASTEXITCODE" }

      - name: Install dependencies
        shell: pwsh
        run: |
          # Match local layout: .build\vcpkg_installed\x64-windows
          .\vcpkg\vcpkg.exe install --triplet x64-windows --x-manifest-root $env:GITHUB_WORKSPACE --x-install-root "$env:GITHUB_WORKSPACE\\.build\\vcpkg_installed"

      - name: Enable vcpkg MSBuild integration
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          .\vcpkg\vcpkg.exe integrate install

      - name: Normalize vcpkg install root
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $dest = Join-Path $env:GITHUB_WORKSPACE ".build\\vcpkg_installed\\x64-windows"
          $expected = Join-Path $dest "include\\wil\\com.h"
          if (Test-Path $expected) {
            Write-Host ".build\\vcpkg_installed already contains WIL headers."
            exit 0
          }

          $candidates = @(
            (Join-Path $env:GITHUB_WORKSPACE "vcpkg\\installed\\x64-windows"),
            (Join-Path $env:GITHUB_WORKSPACE "vcpkg\\installed\\x64-windows-release")
          )

          $source = $candidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $source) {
            Write-Host "Expected WIL header not found at: $expected" -ForegroundColor Yellow
            Write-Host "Searched install roots:" -ForegroundColor Yellow
            $candidates | ForEach-Object { Write-Host "  - $_" }
            Write-Host ".build\\vcpkg_installed contents:" -ForegroundColor Yellow
            Get-ChildItem -Path (Join-Path $env:GITHUB_WORKSPACE ".build\\vcpkg_installed") -ErrorAction SilentlyContinue | Select-Object Name
            Write-Host "vcpkg contents:" -ForegroundColor Yellow
            Get-ChildItem -Path (Join-Path $env:GITHUB_WORKSPACE "vcpkg") -ErrorAction SilentlyContinue | Select-Object Name
            throw "vcpkg install root not found to normalize."
          }

          Write-Host "Syncing $source -> $dest"
          New-Item -ItemType Directory -Path $dest -Force | Out-Null
          & robocopy.exe $source $dest /E /R:1 /W:1 /NFL /NDL /NJH /NJS /NP | Out-Null
          if ($LASTEXITCODE -ge 8) {
            throw "robocopy failed with exit code $LASTEXITCODE"
          }

          if (-not (Test-Path $expected)) {
            throw "Expected WIL header not found after sync: $expected"
          }

      - name: Debug include paths (WIL)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Write-Host "Workspace: $env:GITHUB_WORKSPACE"
          Write-Host "PWD: $(Get-Location)"
          $incRoot = Join-Path $env:GITHUB_WORKSPACE ".build\\vcpkg_installed\\x64-windows\\include"
          Write-Host "Include root: $incRoot"
          Write-Host "Has wil\\com.h: $(Test-Path (Join-Path $incRoot 'wil\\com.h'))"
          Write-Host "Has wil\\resource.h: $(Test-Path (Join-Path $incRoot 'wil\\resource.h'))"
          if (Test-Path (Join-Path $incRoot 'wil')) {
            Get-ChildItem -Path (Join-Path $incRoot 'wil') -ErrorAction SilentlyContinue | Select-Object -First 20 Name
          }
          Write-Host "FileSystem.vcxproj include settings:"
          Select-String -Path 'Plugins\\FileSystem\\FileSystem.vcxproj' -Pattern 'ExternalIncludePath|AdditionalIncludeDirectories' | ForEach-Object { $_.Line.Trim() }
          Write-Host "ViewerText.vcxproj include settings:"
          Select-String -Path 'Plugins\\ViewerText\\ViewerText.vcxproj' -Pattern 'ExternalIncludePath|AdditionalIncludeDirectories' | ForEach-Object { $_.Line.Trim() }

      - name: Build solution
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # CI runners don't always include Visual Studio's vcpkg MSBuild integration component.
          # Provide vcpkg include/lib paths explicitly so compilation and linking can resolve dependencies.
          $vcpkgTriplet = "x64-windows"
          $vcpkgRoot = Join-Path $env:GITHUB_WORKSPACE ".build\\vcpkg_installed\\$vcpkgTriplet"
          $incRoot = Join-Path $vcpkgRoot "include"
          $libRoot = Join-Path $vcpkgRoot "lib"
          $binRoot = Join-Path $vcpkgRoot "bin"

          if (-not (Test-Path $incRoot)) { throw "vcpkg include root not found: $incRoot" }
          if (-not (Test-Path $libRoot)) { throw "vcpkg lib root not found: $libRoot" }

          $env:CL = "/I`"$incRoot`" $env:CL"

          $linkPaths = @($libRoot)
          $libManualRoot = Join-Path $libRoot "manual-link"
          if (Test-Path $libManualRoot) { $linkPaths += $libManualRoot }
          $linkFlags = ($linkPaths | ForEach-Object { "/LIBPATH:`"$_`"" }) -join ' '
          $env:LINK = "$linkFlags $env:LINK"

          if (Test-Path $binRoot) { $env:Path = "$binRoot;$env:Path" }

          if ($env:BUILD_MSIX -eq "true") {
            .\build.ps1 -Configuration $env:CONFIGURATION -Platform $env:PLATFORM -Msix
          } else {
            .\build.ps1 -Configuration $env:CONFIGURATION -Platform $env:PLATFORM
          }

      - name: Install WiX Toolset CLI (MSI)
        shell: pwsh
        run: |
          winget install --exact --id WiXToolset.WiXCLI --accept-source-agreements --accept-package-agreements

      - name: Build MSI
        shell: pwsh
        run: |
          .\Installer\msi\build-msi.ps1 -Configuration $env:CONFIGURATION -Platform $env:PLATFORM

      - name: Build Symbols MSI (PDB)
        shell: pwsh
        run: |
          .\Installer\msi\build-msi-symbols.ps1 -Configuration $env:CONFIGURATION -Platform $env:PLATFORM

      - name: Package artifacts
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $PSNativeCommandUseErrorActionPreference = $false

          $outDir = Join-Path $env:GITHUB_WORKSPACE "artifacts"
          New-Item -ItemType Directory -Path $outDir -Force | Out-Null

          $stageDir = Join-Path $env:RUNNER_TEMP "RedSalamanderPortable"
          if (Test-Path $stageDir) { Remove-Item $stageDir -Recurse -Force }
          New-Item -ItemType Directory -Path $stageDir -Force | Out-Null
          
          $releaseDir = Join-Path (".build\\{0}" -f $env:PLATFORM) $env:CONFIGURATION
          if (-not (Test-Path $releaseDir)) {
            Write-Host "Available build output directories:" -ForegroundColor Yellow
            Get-ChildItem -Path (".build\\{0}" -f $env:PLATFORM) -Directory -ErrorAction SilentlyContinue | Select-Object Name
            throw "Build output directory not found: $releaseDir"
          }

          $exclude = @("*.pdb","*.lib","*.exp","*.ilk","*.iobj","*.ipdb","*.pch","*.exe","asan.supp","aws-cpp-sdk-dynamodb.dll","aws-cpp-sdk-kinesis.dll","aws-cpp-sdk-s3.dll","brotlienc.dll")
          & robocopy.exe $releaseDir $stageDir "/E" "/R:1" "/W:1" "/NFL" "/NDL" "/NJH" "/NJS" "/NP" "/XF" @exclude | Out-Null
          $rc = $LASTEXITCODE
          $global:LASTEXITCODE = 0
          if ($rc -ge 8) { throw "robocopy (portable stage) failed with exit code $rc" }

          & robocopy.exe $releaseDir $stageDir "RedSalamander.exe" "RedSalamanderMonitor.exe" "/R:1" "/W:1" "/NFL" "/NDL" "/NJH" "/NJS" "/NP" | Out-Null
          $rc = $LASTEXITCODE
          $global:LASTEXITCODE = 0
          if ($rc -ge 8) { throw "robocopy (portable exes) failed with exit code $rc" }

          $zipPath = Join-Path $outDir "RedSalamander-x64-Release.zip"
          if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
          Compress-Archive -Path (Join-Path $stageDir "*") -DestinationPath $zipPath

          $msiFiles = Get-ChildItem -Path ".build\\AppPackages" -Filter *.msi -Recurse -ErrorAction SilentlyContinue
          if (-not $msiFiles) {
            throw "No MSI artifacts found under .build\\AppPackages."
          }
          foreach ($msiFile in $msiFiles) {
            Copy-Item $msiFile.FullName -Destination $outDir -Force
          }

          if ($env:BUILD_MSIX -eq "true") {
            $msixFiles = Get-ChildItem -Path ".build\\AppPackages" -Filter *.msix -Recurse -ErrorAction SilentlyContinue
            if (-not $msixFiles) {
              throw "BUILD_MSIX=true but no MSIX artifacts found under .build\\AppPackages."
            }
            foreach ($msixFile in $msixFiles) {
              Copy-Item $msixFile.FullName -Destination $outDir -Force
            }
          }

          exit 0

      - name: Sign MSIX
        if: ${{ env.BUILD_MSIX == 'true' && (github.event_name != 'workflow_dispatch' || inputs.sign_msix) }}
        shell: pwsh
        env:
          MSIX_SIGNING_CERT: ${{ secrets.MSIX_SIGNING_CERT }}
          MSIX_SIGNING_PASSWORD: ${{ secrets.MSIX_SIGNING_PASSWORD }}
        run: |
          $ErrorActionPreference = "Stop"

          if ([string]::IsNullOrWhiteSpace($env:MSIX_SIGNING_CERT) -or [string]::IsNullOrWhiteSpace($env:MSIX_SIGNING_PASSWORD)) {
            Write-Host "MSIX signing secrets not configured; skipping signing step."
            exit 0
          }

          $certPath = Join-Path $env:RUNNER_TEMP "msix.pfx"
          [IO.File]::WriteAllBytes($certPath, [Convert]::FromBase64String($env:MSIX_SIGNING_CERT))
          $msixFiles = Get-ChildItem -Path "artifacts" -Filter *.msix
          if ($msixFiles.Count -eq 0) { throw "No MSIX found to sign." }

          $signtoolPath = $null
          $signtool = Get-Command signtool.exe -ErrorAction SilentlyContinue
          if ($signtool) {
            $signtoolPath = $signtool.Source
          } else {
            $kitsBin = Join-Path ${env:ProgramFiles(x86)} "Windows Kits\\10\\bin"
            $versionDirs =
              Get-ChildItem -Path $kitsBin -Directory -ErrorAction SilentlyContinue |
              Where-Object { $_.Name -match '^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$' } |
              Sort-Object -Property Name -Descending

            foreach ($dir in $versionDirs) {
              $candidate = Join-Path $dir.FullName "x64\\signtool.exe"
              if (Test-Path $candidate) {
                $signtoolPath = $candidate
                break
              }
            }
          }

          if (-not $signtoolPath) {
            throw "signtool.exe not found (Windows SDK missing on runner)."
          }

          foreach ($msix in $msixFiles) {
            & $signtoolPath sign /fd SHA256 /f $certPath /p $env:MSIX_SIGNING_PASSWORD /tr http://timestamp.digicert.com /td SHA256 $msix.FullName
          }

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: RedSalamander-Release
          path: artifacts/*

      - name: Create GitHub release
        if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.release_tag != '') }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event_name == 'workflow_dispatch' && inputs.release_tag || github.ref_name }}
          fail_on_unmatched_files: true
          files: |
            artifacts/*.msi
            artifacts/*.zip

      - name: Upload MSIX to GitHub release
        if: ${{ env.BUILD_MSIX == 'true' && (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.release_tag != '')) }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event_name == 'workflow_dispatch' && inputs.release_tag || github.ref_name }}
          fail_on_unmatched_files: true
          files: |
            artifacts/*.msix
