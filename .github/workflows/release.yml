name: Release

"on":
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Tag to release (e.g., v7.0.0). Leave blank to skip release creation."
        required: false
        type: string
      build_msix:
        description: "Also build MSIX (off by default)."
        required: false
        type: boolean
        default: false
      sign_msix:
        description: "Sign MSIX if certificate secrets are configured (only if build_msix=true)."
        required: false
        type: boolean
        default: true

permissions:
  contents: write

# ════════════════════════════════════════════════════════════════════════
# Job 1: Build (matrix: x64, ARM64 — parallel via reusable workflow)
# ════════════════════════════════════════════════════════════════════════

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        platform: [x64, ARM64]
    uses: ./.github/workflows/build-reusable.yml
    with:
      configuration: Release
      platform: ${{ matrix.platform }}
      upload_build_output: true

  # ══════════════════════════════════════════════════════════════════════
  # Job 2: Package portable ZIP (no VS needed)
  # ══════════════════════════════════════════════════════════════════════

  package-portable:
    runs-on: windows-latest
    needs: build
    if: ${{ !cancelled() }}
    strategy:
      fail-fast: false
      matrix:
        platform: [x64, ARM64]
    steps:
      - name: Download build output
        uses: actions/download-artifact@v4
        with:
          name: build-output-${{ matrix.platform }}
          path: .build/${{ matrix.platform }}/Release/

      - name: Stage portable files and create ZIP
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $PSNativeCommandUseErrorActionPreference = $false

          $releaseDir = Join-Path $env:GITHUB_WORKSPACE ".build\${{ matrix.platform }}\Release"
          $stageDir = Join-Path $env:RUNNER_TEMP "RedSalamanderPortable"
          if (Test-Path $stageDir) { Remove-Item $stageDir -Recurse -Force }
          New-Item -ItemType Directory -Path $stageDir -Force | Out-Null

          # Copy everything except build artifacts and non-shipping files
          $exclude = @("*.pdb","*.lib","*.exp","*.ilk","*.iobj","*.ipdb","*.pch","*.exe","asan.supp","aws-cpp-sdk-dynamodb.dll","aws-cpp-sdk-kinesis.dll","aws-cpp-sdk-s3.dll","brotlienc.dll")
          & robocopy.exe $releaseDir $stageDir "/E" "/R:1" "/W:1" "/NFL" "/NDL" "/NJH" "/NJS" "/NP" "/XF" @exclude | Out-Null
          $rc = $LASTEXITCODE
          $global:LASTEXITCODE = 0
          if ($rc -ge 8) { throw "robocopy (portable stage) failed with exit code $rc" }

          # Copy shipping executables explicitly
          & robocopy.exe $releaseDir $stageDir "RedSalamander.exe" "RedSalamanderMonitor.exe" "/R:1" "/W:1" "/NFL" "/NDL" "/NJH" "/NJS" "/NP" | Out-Null
          $rc = $LASTEXITCODE
          $global:LASTEXITCODE = 0
          if ($rc -ge 8) { throw "robocopy (portable exes) failed with exit code $rc" }

          # Create ZIP
          $outDir = Join-Path $env:GITHUB_WORKSPACE "artifacts"
          New-Item -ItemType Directory -Path $outDir -Force | Out-Null
          $zipPath = Join-Path $outDir "RedSalamander-${{ matrix.platform }}-Release.zip"
          if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
          Compress-Archive -Path (Join-Path $stageDir "*") -DestinationPath $zipPath

      - name: Upload portable package
        uses: actions/upload-artifact@v4
        with:
          name: portable-package-${{ matrix.platform }}
          path: artifacts/*.zip
          retention-days: 1

  # ══════════════════════════════════════════════════════════════════════
  # Job 3: Package MSI (no VS needed — WiX CLI only)
  # ══════════════════════════════════════════════════════════════════════

  package-msi:
    runs-on: windows-latest
    needs: build
    if: ${{ !cancelled() }}
    strategy:
      fail-fast: false
      matrix:
        platform: [x64, ARM64]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download build output
        uses: actions/download-artifact@v4
        with:
          name: build-output-${{ matrix.platform }}
          path: .build/${{ matrix.platform }}/Release/

      - name: Install WiX Toolset CLI
        shell: pwsh
        run: |
          winget install --exact --id WiXToolset.WiXCLI --accept-source-agreements --accept-package-agreements

      - name: Build MSI
        shell: pwsh
        run: |
          $msiScript = Join-Path $env:GITHUB_WORKSPACE "Installer\msi\build-msi.ps1"
          if (-not (Test-Path $msiScript)) { throw "MSI build script not found at: $msiScript" }
          & $msiScript -Configuration Release -Platform ${{ matrix.platform }}

      - name: Build Symbols MSI (PDB)
        shell: pwsh
        run: |
          $msiSymbolsScript = Join-Path $env:GITHUB_WORKSPACE "Installer\msi\build-msi-symbols.ps1"
          if (-not (Test-Path $msiSymbolsScript)) { throw "Symbols MSI build script not found at: $msiSymbolsScript" }
          & $msiSymbolsScript -Configuration Release -Platform ${{ matrix.platform }}

      - name: Upload MSI packages
        uses: actions/upload-artifact@v4
        with:
          name: msi-package-${{ matrix.platform }}
          path: .build/AppPackages/*.msi
          retention-days: 1

  # ══════════════════════════════════════════════════════════════════════
  # Job 4: Package MSIX (conditional — needs VS + Windows SDK)
  # ══════════════════════════════════════════════════════════════════════

  package-msix:
    runs-on: windows-latest
    needs: build
    if: ${{ !cancelled() && github.event_name == 'workflow_dispatch' && inputs.build_msix }}
    strategy:
      fail-fast: false
      matrix:
        platform: [x64, ARM64]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download build output
        uses: actions/download-artifact@v4
        with:
          name: build-output-${{ matrix.platform }}
          path: .build/${{ matrix.platform }}/Release/

      - name: Install VS 2026 Build Tools + VC++ + UWP workloads
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          choco install visualstudio2026buildtools -y --no-progress
          if ($LASTEXITCODE -notin 0,3010) { throw "VS Build Tools install failed: $LASTEXITCODE" }
          choco install visualstudio2026-workload-vctools -y --no-progress
          if ($LASTEXITCODE -notin 0,3010) { throw "VC workload install failed: $LASTEXITCODE" }
          choco install visualstudio2026-workload-universalbuildtools -y --no-progress
          if ($LASTEXITCODE -notin 0,3010) { throw "UWP workload install failed: $LASTEXITCODE" }

      - name: Select MSBuild (VS 2026)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (-not (Test-Path $vswhere)) {
            throw "vswhere.exe not found: $vswhere"
          }

          $msbuild =
            (& $vswhere -latest -products * -prerelease -version '[18.0,19.0)' -find 'MSBuild\Current\Bin\MSBuild.exe' 2>$null) |
            Select-Object -First 1

          if (-not $msbuild) {
            $msbuild =
              (& $vswhere -latest -products * -prerelease -version '[18.0,19.0)' -find 'MSBuild\Current\Bin\amd64\MSBuild.exe' 2>$null) |
              Select-Object -First 1
          }

          if (-not $msbuild -or -not (Test-Path $msbuild)) {
            Write-Host "Installed Visual Studio instances:" -ForegroundColor Yellow
            & $vswhere -all -prerelease -products *
            throw "MSBuild for Visual Studio 2026 (18.x) not found after installation."
          }

          $msbuildDir = Split-Path -Parent $msbuild
          $msbuildDir | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          "MSBUILD_EXE_PATH=$msbuild" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          & $msbuild -version

      - name: Generate MSIX assets
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          & (Join-Path $env:GITHUB_WORKSPACE "Installer\msix\GenerateAssets.ps1")

      - name: Build MSIX package
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $platform = "${{ matrix.platform }}"
          $wapproj = Join-Path $env:GITHUB_WORKSPACE "Installer\msix\RedSalamanderInstaller.wapproj"
          $solutionDir = $env:GITHUB_WORKSPACE.TrimEnd('\') + '\'

          # Resolve TargetPlatformVersion from installed Windows SDK
          $uapRoot = Join-Path ${env:ProgramFiles(x86)} "Windows Kits\10\DesignTime\CommonConfiguration\Neutral\UAP"
          $installed = Get-ChildItem -Path $uapRoot -Directory -ErrorAction SilentlyContinue |
              Where-Object { $_.Name -match '^\d+\.\d+\.\d+\.\d+$' } |
              Sort-Object { [version]$_.Name } -Descending |
              Select-Object -First 1

          if (-not $installed) {
            throw "Windows SDK with UAP props not found."
          }
          $targetPlatformVersion = $installed.Name

          $msixParams = @(
            $wapproj
            "/t:Build"
            "/p:Configuration=Release"
            "/p:Platform=$platform"
            "/p:TargetPlatformVersion=$targetPlatformVersion"
            "/p:SolutionDir=$solutionDir"
            "/p:AppxPackageSigningEnabled=false"
            "/p:GenerateAppInstallerFile=false"
            "/p:AppxBundle=Never"
            "/v:minimal"
            "/nologo"
          )

          MSBuild.exe @msixParams
          if ($LASTEXITCODE -ne 0) { throw "MSIX build failed with exit code $LASTEXITCODE" }

      - name: Sign MSIX
        if: ${{ github.event_name != 'workflow_dispatch' || inputs.sign_msix }}
        shell: pwsh
        env:
          MSIX_SIGNING_CERT: ${{ secrets.MSIX_SIGNING_CERT }}
          MSIX_SIGNING_PASSWORD: ${{ secrets.MSIX_SIGNING_PASSWORD }}
        run: |
          $ErrorActionPreference = "Stop"

          if ([string]::IsNullOrWhiteSpace($env:MSIX_SIGNING_CERT) -or [string]::IsNullOrWhiteSpace($env:MSIX_SIGNING_PASSWORD)) {
            Write-Host "MSIX signing secrets not configured; skipping signing step."
            exit 0
          }

          $certPath = Join-Path $env:RUNNER_TEMP "msix.pfx"
          [IO.File]::WriteAllBytes($certPath, [Convert]::FromBase64String($env:MSIX_SIGNING_CERT))

          $appPackages = Join-Path $env:GITHUB_WORKSPACE ".build\AppPackages"
          $msixFiles = Get-ChildItem -Path $appPackages -Filter *.msix -Recurse -ErrorAction SilentlyContinue
          if (-not $msixFiles -or $msixFiles.Count -eq 0) { throw "No MSIX found to sign." }

          $signtoolPath = $null
          $signtool = Get-Command signtool.exe -ErrorAction SilentlyContinue
          if ($signtool) {
            $signtoolPath = $signtool.Source
          } else {
            $kitsBin = Join-Path ${env:ProgramFiles(x86)} "Windows Kits\10\bin"
            $versionDirs =
              Get-ChildItem -Path $kitsBin -Directory -ErrorAction SilentlyContinue |
              Where-Object { $_.Name -match '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' } |
              Sort-Object -Property Name -Descending

            foreach ($dir in $versionDirs) {
              $candidate = Join-Path $dir.FullName "x64\signtool.exe"
              if (Test-Path $candidate) {
                $signtoolPath = $candidate
                break
              }
            }
          }

          if (-not $signtoolPath) {
            throw "signtool.exe not found (Windows SDK missing on runner)."
          }

          foreach ($msix in $msixFiles) {
            & $signtoolPath sign /fd SHA256 /f $certPath /p $env:MSIX_SIGNING_PASSWORD /tr http://timestamp.digicert.com /td SHA256 $msix.FullName
          }

      - name: Upload MSIX package
        uses: actions/upload-artifact@v4
        with:
          name: msix-package-${{ matrix.platform }}
          path: .build/AppPackages/**/*.msix
          retention-days: 1

  # ══════════════════════════════════════════════════════════════════════
  # Job 5: Release — download all artifacts, create GitHub Release
  # ══════════════════════════════════════════════════════════════════════

  release:
    runs-on: windows-latest
    needs: [package-portable, package-msi, package-msix]
    if: >-
      always() &&
      !cancelled() &&
      (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.release_tag != ''))
    steps:
      - name: Download portable packages
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          pattern: portable-package-*
          path: artifacts
          merge-multiple: true

      - name: Download MSI packages
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          pattern: msi-package-*
          path: artifacts
          merge-multiple: true

      - name: Download MSIX packages
        if: ${{ needs.package-msix.result == 'success' }}
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          pattern: msix-package-*
          path: artifacts
          merge-multiple: true

      - name: Verify release artifacts exist
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          if (-not (Test-Path artifacts)) {
            throw "No artifacts directory found — all builds failed."
          }
          $files = Get-ChildItem -Path artifacts -File -Recurse | Where-Object { $_.Extension -in '.msi','.zip','.msix' }
          if (-not $files -or $files.Count -eq 0) {
            throw "No release artifacts found (all platforms failed)."
          }
          Write-Host "Release artifacts:"
          $files | ForEach-Object { Write-Host "  $($_.Name) ($([math]::Round($_.Length / 1MB, 2)) MB)" }

      - name: Generate SHA256 checksums
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $files = Get-ChildItem -Path artifacts -File -Recurse | Where-Object { $_.Extension -in '.msi','.zip','.msix' }
          $checksums = foreach ($f in $files) {
            $hash = (Get-FileHash -Path $f.FullName -Algorithm SHA256).Hash
            "$hash  $($f.Name)"
          }
          $checksums | Out-File -FilePath "artifacts\checksums.sha256" -Encoding utf8
          Write-Host "Checksums:"
          $checksums | ForEach-Object { Write-Host "  $_" }

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event_name == 'workflow_dispatch' && inputs.release_tag || github.ref_name }}
          fail_on_unmatched_files: false
          files: |
            artifacts/*.msi
            artifacts/*.zip
            artifacts/*.sha256

      - name: Upload MSIX to release
        if: ${{ needs.package-msix.result == 'success' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event_name == 'workflow_dispatch' && inputs.release_tag || github.ref_name }}
          fail_on_unmatched_files: true
          files: artifacts/*.msix
